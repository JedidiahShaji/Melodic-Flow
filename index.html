<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MelodicFlow: A Generative Music Box</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <!-- Load Google Font (Inter for UI) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        /* Custom styles for the app */
        body {
            /* Set default font to Inter */
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* NEW: Premium Inset Title Style */
        .title-premium-inset {
            font-size: 2.5rem; /* 40px */
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #4B5563; /* gray-600 */
            /* Inset shadow effect */
            text-shadow: 0 1px 1px #1F2937, /* Top shadow (dark) */
                         0 -1px 1px #6B7280; /* Bottom highlight (light) */
        }

        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #374151; /* gray-700 */
            border-radius: 9999px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #F0F0F0; /* Lighter gray for the thumb */
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #FFFFFF;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #F0F0F0;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #FFFFFF;
        }

        /* Canvas styles */
        #visual-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Mood switcher buttons */
        .mood-btn {
            background-color: #374151; /* gray-700 */
            color: #9CA3AF; /* gray-400 */
            padding: 8px 16px;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
        }
        .mood-btn:hover {
            background-color: #4B5563; /* gray-600 */
            color: #FFFFFF;
        }
        .mood-btn.mood-active {
            background-color: #F0F0F0;
            color: #111827; /* gray-900 */
            box-shadow: 0 4px 14px rgba(200, 200, 200, 0.1);
        }
        
        /* Focus mode outline buttons */
        .focus-btn {
            background-color: transparent;
            color: #9CA3AF; /* gray-400 */
            padding: 6px 14px;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
            border: 1px solid #4B5563; /* gray-600 */
        }
        .focus-btn:hover {
            background-color: #374151; /* gray-700 */
            color: #FFFFFF;
        }
        
        /* Stop button styling */
        #stopFocusBtn {
            background-color: #B91C1C; /* red-700 */
            color: #FFFFFF;
            font-weight: 500;
            padding: 10px 16px;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
        }
        #stopFocusBtn:hover {
            background-color: #991B1B; /* red-800 */
        }
        
        /* Helper for smooth hide/show transitions */
        .fade-out {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none;
            position: absolute; /* Take out of flow when hiding */
        }
        .fade-in {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s ease-in, transform 0.3s ease-in;
            pointer-events: auto;
            position: relative;
        }
        /* Container to manage the fade transition height */
        .transition-container {
            position: relative;
            min-height: 120px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* Record button styles */
        #recordButton {
            background-color: #1F2937; /* gray-800 */
            color: #FCA5A5; /* red-300 */
            border: 1px solid #B91C1C; /* red-700 */
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
        }
        #recordButton:hover {
            background-color: #B91C1C;
            color: #FFFFFF;
        }
        #recordButton.is-recording {
            background-color: #B91C1C;
            color: #FFFFFF;
            animation: pulse 1.5s infinite;
        }
        /* Logic for disabled record button */
        #recordButton:disabled {
            background-color: #374151; /* gray-700 */
            color: #6B7280; /* gray-500 */
            border-color: #4B5563; /* gray-600 */
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Share button styles */
        #shareButton {
            background-color: transparent;
            color: #818CF8; /* indigo-300 */
            border: 1px solid #4F46E5; /* indigo-600 */
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 9999px;
            transition: all 0.2s ease-in-out;
        }
        #shareButton:hover {
            background-color: #4F46E5;
            color: #FFFFFF;
        }

        /* Preset menu styles */
        #presetMenu {
            background-color: #374151; /* gray-700 */
            color: #F0F0F0;
            border: 1px solid #4B5563; /* gray-600 */
            border-radius: 8px;
            padding: 8px 12px;
            flex-grow: 1; /* Take up available space */
        }
        #deletePresetButton {
            background-color: transparent;
            color: #EF4444; /* red-500 */
            border: 1px solid #B91C1C; /* red-700 */
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
        }
        #deletePresetButton:hover {
            background-color: #B91C1C;
            color: #FFFFFF;
        }
        
        /* Inline text input for saving */
        #presetNameInput {
            background-color: #374151; /* gray-700 */
            color: #F0F0F0;
            border: 1px solid #4B5563; /* gray-600 */
            border-radius: 8px;
            padding: 8px 12px;
            flex-grow: 1;
        }
        
        /* Helper for hiding/showing elements cleanly */
        .hidden {
            display: none;
        }


        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <!-- REFACTORED: Changed max-w-lg to max-w-4xl for grid layout -->
    <div class="max-w-4xl w-full p-6 space-y-6">
        
        <!-- Header -->
        <header class="text-center">
            <!-- REFACTORED: Using new premium inset title class -->
            <h1 class="title-premium-inset">MelodicFlow</h1>
            <p class="text-lg text-gray-400">A Generative Music Box</p>
        </header>

        <!-- Pulsing Visual (Moved up) -->
        <!-- REFACTORED: Replaced div with a canvas container -->
        <div class="flex justify-center items-center h-20">
            <div id="visual-container" class="w-full h-full bg-gray-800 rounded-lg overflow-hidden shadow-inner">
                <canvas id="visual-canvas"></canvas>
            </div>
        </div>
        
        <!-- REFACTORED: New Grid Container for modular cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

            <!-- Card 1 - Transport / Master Control -->
            <div class="bg-gray-800 shadow-xl rounded-2xl p-6 space-y-6">
                <!-- NEW: Changed title to be clearer -->
                <h2 class="text-lg font-medium text-gray-300 mb-2 text-center">Master Control</h2>
                <!-- Transition Container for Start/Stop/Focus -->
                <div class="transition-container">
                    
                    <!-- Idle State (Start + Focus Times) -->
                    <div id="idleControls" class="fade-in w-full text-center space-y-4">
                        <!-- Start Button -->
                        <button id="startButton" class="w-full bg-indigo-600 text-white font-semibold py-3 px-4 rounded-lg shadow-lg hover:bg-indigo-500 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75" disabled>
                            Loading Audio...
                        </button>
                        
                        <!-- Timer Selection -->
                        <div id="focusTimeSelector" class="flex justify-center space-x-2">
                            <button class="focus-btn" data-time="15">15 min</button>
                            <button class="focus-btn" data-time="25">25 min</button>
                            <button class="focus-btn" data-time="45">45 min</button>
                        </div>
                    </div>

                    <!-- Active State (Timer Display + Stop) -->
                    <div id="activeControls" class="fade-out w-full text-center space-y-4">
                        <div class="text-5xl font-bold text-white tabular-nums" id="timerDisplay">...</div>
                        <button id="stopFocusBtn">Stop</button>
                    </div>
                    
                </div>
            </div>

            <!-- Card 2 - Sound Palette -->
            <div class="bg-gray-800 shadow-xl rounded-2xl p-6 space-y-6">
                <h2 class="text-lg font-medium text-gray-300 mb-2">Sound Palette</h2>
                
                <!-- Mood Switcher (Moved) -->
                <div id="moodSwitcher" class="flex justify-center space-x-2">
                    <button class="mood-btn mood-active" data-mood="ambient">Ambient</button>
                    <button class="mood-btn" data-mood="lofi">Lofi</button>
                    <button class="mood-btn" data-mood="dance">Dance</button>
                </div>

                <!-- Note Density Slider (Moved) -->
                <div class="space-y-2 pt-4 border-t border-gray-700">
                    <div class="flex justify-between items-center">
                        <label for="densitySlider" class="text-sm font-medium text-gray-300">Note Density</label>
                        <span id="densityValue" class="text-sm text-gray-400 tabular-nums">35%</span>
                    </div>
                    <input type="range" id="densitySlider" min="0" max="100" value="35" class="w-full">
                    <!-- Added helper text for clarity -->
                    <p class="text-xs text-gray-500 italic pt-1">Controls the chance of a note playing on each beat.</p>
                </div>
            </div>
            
            <!-- Card 3 - FX & Mixer -->
            <div class="bg-gray-800 shadow-xl rounded-2xl p-6 space-y-6">
                <h2 class="text-lg font-medium text-gray-300 mb-2">FX & Mixer</h2>
                
                <!-- Tempo Slider -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label for="tempoSlider" class="text-sm font-medium text-gray-300">Tempo</label>
                        <span id="tempoValue" class="text-sm text-gray-400 tabular-nums">90 bpm</span>
                    </div>
                    <input type="range" id="tempoSlider" min="60" max="160" value="90" class="w-full">
                </div>

                <!-- Reverb Slider -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label for="reverbSlider" class="text-sm font-medium text-gray-300">Reverb (Wet)</label>
                        <span id="reverbValue" class="text-sm text-gray-400 tabular-nums">25%</span>
                    </div>
                    <input type="range" id="reverbSlider" min="0" max="100" value="25" class="w-full">
                </div>

                <!-- Delay Slider -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label for="delaySlider" class="text-sm font-medium text-gray-300">Delay (Mix)</label>
                        <span id="delayValue" class="text-sm text-gray-400 tabular-nums">10%</span>
                    </div>
                    <input type="range" id="delaySlider" min="0" max="100" value="10" class="w-full">
                </div>
            </div>

            <!-- Card 4 - Output -->
            <div class="bg-gray-800 shadow-xl rounded-2xl p-6">
                <h2 class="text-lg font-medium text-gray-300 mb-4 text-center">Output</h2>
                <!-- Export Audio Section (Moved) -->
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <button id="recordButton" class="sm:col-span-1" disabled>Record</button>
                    <button id="shareButton" class="sm:col-span-1">Share</button>
                </div>
                <p id="recordHelpText" class="text-xs text-gray-500 mt-3 text-center">Start music to enable recording.</p>
            </div>
            
            <!-- REFACTORED: Card 5 - Presets (Now with inline saving UI) -->
            <div class="bg-gray-800 shadow-xl rounded-2xl p-6 md:col-span-2 space-y-4">
                <h2 class="text-lg font-medium text-gray-300">My Presets</h2>
                
                <!-- Preset Loading UI (Always visible) -->
                <div id="loadPresetUI" class="flex flex-col sm:flex-row gap-4">
                    <select id="presetMenu" name="presetMenu">
                        <option value="">Select a preset...</option>
                        <!-- Presets will be loaded here by JS -->
                    </select>
                    <button id="deletePresetButton" class="focus-btn">Delete</button>
                    <button id="savePresetButton" class="focus-btn border-emerald-600 text-emerald-400 hover:bg-emerald-600 hover:text-white">Save Current</button>
                </div>

                <!-- NEW: Preset Deleting UI (Hidden by default) -->
                <div id="deleteConfirmUI" class="hidden flex-col sm:flex-row gap-4 items-center">
                    <span class="text-sm text-gray-300 flex-grow">Delete this preset?</span>
                    <button id="confirmDeleteButton" class="focus-btn border-red-700 text-red-500 hover:bg-red-700 hover:text-white">Yes, Delete</button>
                    <button id="cancelDeleteButton" class="focus-btn">Cancel</button>
                </div>
                
                <!-- NEW: Preset Saving UI (Hidden by default) -->
                <div id="savePresetUI" class="hidden flex-col sm:flex-row gap-4">
                    <input type="text" id="presetNameInput" placeholder="Enter preset name..." />
                    <button id="confirmSaveButton" class="focus-btn border-emerald-600 text-emerald-400 hover:bg-emerald-600 hover:text-white">Save</button>
                    <button id="cancelSaveButton" class="focus-btn">Cancel</button>
                </div>

                <!-- NEW: Preset help text area -->
                <p id="presetHelpText" class="text-xs text-gray-500 h-4"></p> <!-- Empty space for messages -->
            </div>

        </div> <!-- End of Grid Container -->

        <!-- NEW: Hidden textarea for clipboard copy -->
        <textarea id="shareTextArea" class="absolute -left-full"></textarea>

    </div>

    <script>
        // --- UI Elements ---
        const startButton = document.getElementById('startButton');
        const densitySlider = document.getElementById('densitySlider');
        const densityValue = document.getElementById('densityValue');
        const reverbSlider = document.getElementById('reverbSlider');
        const reverbValue = document.getElementById('reverbValue');
        const tempoSlider = document.getElementById('tempoSlider');
        const tempoValue = document.getElementById('tempoValue');
        const delaySlider = document.getElementById('delaySlider');
        const delayValue = document.getElementById('delayValue');
        const moodSwitcher = document.getElementById('moodSwitcher');
        
        // NEW: Canvas and Analyser Elements
        const visualContainer = document.getElementById('visual-container');
        const visualCanvas = document.getElementById('visual-canvas');
        const canvasCtx = visualCanvas.getContext('2d');

        // Focus UI Elements
        const idleControls = document.getElementById('idleControls');
        const activeControls = document.getElementById('activeControls');
        const focusTimeSelector = document.getElementById('focusTimeSelector');
        const timerDisplay = document.getElementById('timerDisplay');
        const stopFocusBtn = document.getElementById('stopFocusBtn');
        
        let focusTimerInterval = null;
        let focusTimerEndTime = 0;
        let isFocusMode = false;

        let isPlaying = false;
        let density = 0.35; // Default density
        let currentMood = 'ambient'; // NEW: Global mood tracker

        // --- Audio Recorder Elements ---
        const recordButton = document.getElementById('recordButton');
        const recordHelpText = document.getElementById('recordHelpText'); // New help text element
        
        // --- REFACTORED: Preset Elements ---
        const loadPresetUI = document.getElementById('loadPresetUI');
        const savePresetUI = document.getElementById('savePresetUI');
        const deleteConfirmUI = document.getElementById('deleteConfirmUI');
        const savePresetButton = document.getElementById('savePresetButton');
        const presetNameInput = document.getElementById('presetNameInput');
        const confirmSaveButton = document.getElementById('confirmSaveButton');
        const cancelSaveButton = document.getElementById('cancelSaveButton');
        const presetMenu = document.getElementById('presetMenu');
        const deletePresetButton = document.getElementById('deletePresetButton');
        const confirmDeleteButton = document.getElementById('confirmDeleteButton');
        const cancelDeleteButton = document.getElementById('cancelDeleteButton');
        const presetHelpText = document.getElementById('presetHelpText');
        const PRESETS_STORAGE_KEY = 'melodicFlowPresets';

        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        // Create a new audio "destination" node for recording
        const recordDestination = Tone.context.createMediaStreamDestination();

        // --- 1. Define all our Instruments ---

        // 1a. Main Melody Synth
        const synth = new Tone.FMSynth({
            "harmonicity": 3.01,
            "modulationIndex": 14,
            "oscillator": { "type": "sine" },
            "envelope": { "attack": 0.01, "decay": 0.1, "sustain": 0.1, "release": 1.2 },
            "modulation": { "type": "square" },
            "modulationEnvelope": { "attack": 0.02, "decay": 0.2, "sustain": 0.3, "release": 1.2 }
        });

        // 1b. Ambient Pad Synth
        const padSynth = new Tone.PolySynth(Tone.FMSynth, {
            "volume": -12, // Quieter than the main synth
            "harmonicity": 1,
            "oscillator": { "type": "fatsawtooth" },
            "envelope": { "attack": 1.5, "decay": 0.1, "sustain": 1, "release": 3 },
        });

        // --- Pad Synth Presets ---
        const padPresets = {
            ambient: {
                "harmonicity": 1,
                "oscillator": { "type": "fatsawtooth" },
                "envelope": { "attack": 1.5, "decay": 0.1, "sustain": 1, "release": 3 },
            },
            lofi: {
                "harmonicity": 1,
                "oscillator": { "type": "fatsine" }, // More like a rhodes
                "envelope": { "attack": 0.1, "decay": 0.0, "sustain": 1, "release": 1.5 },
            },
            dance: {
                "harmonicity": 1,
                "oscillator": { "type": "sawtooth" }, // Brighter sound
                "envelope": { "attack": 0.01, "decay": 0.1, "sustain": 0.3, "release": 0.5 },
            }
        };

        // 1c. Kick Drum
        const kickSynth = new Tone.MembraneSynth({
            "pitchDecay": 0.05,
            "octaves": 10,
            "oscillator": { "type": "sine" },
            "envelope": { "attack": 0.001, "decay": 0.4, "sustain": 0.01, "release": 1.4 }
        });
        // By default, the kick is muted.
        kickSynth.volume.value = -Infinity;

        // 1d. Hi-Hat
        const hiHatSynth = new Tone.NoiseSynth({
            "noise": { "type": "white" },
            "envelope": { "attack": 0.001, "decay": 0.1, "sustain": 0, "release": 0.1 }
        });
        hiHatSynth.volume.value = -Infinity; // Muted by default

        // --- Hi-Hat Synth Presets ---
        const hiHatPresets = {
            lofi: {
                "noise": { "type": "pink" }, // Warmer/softer 'shaker' sound
                "envelope": { "attack": 0.01, "decay": 0.15, "sustain": 0 }
            },
            dance: {
                "noise": { "type": "white" }, // Brighter/tighter 'hat' sound
                "envelope": { "attack": 0.001, "decay": 0.05, "sustain": 0 }
            }
        };
        
        // 1e. Chime Synth (for timer)
        const chimeSynth = new Tone.FMSynth({
            "harmonicity": 5,
            "modulationIndex": 10,
            "oscillator": { "type": "sine" },
            "envelope": { "attack": 0.01, "decay": 0.5, "sustain": 0.1, "release": 1 },
            "modulation": { "type": "triangle" }
        });


        // --- 2. Define our Effects and Audio Chain ---

        // 2a. Reverb
        // This is our FINAL output. Everything connects to this.
        const reverb = new Tone.Reverb(1.5);
        reverb.wet.value = 0.25; // Default 25%
        
        // Connect reverb to both the speakers AND our recording destination
        reverb.toDestination();
        reverb.connect(recordDestination);


        // 2b. Ping-Pong Delay
        const pingPongDelay = new Tone.PingPongDelay("8n", 0.2);
        pingPongDelay.wet.value = 0.1; // Default 10%
        pingPongDelay.connect(reverb); // Delay feeds into Reverb

        // 2c. Lofi Effects
        const lofiFilter = new Tone.AutoFilter("16n").start();
        lofiFilter.frequency.value = 20000; // Start fully open (clean)
        lofiFilter.depth.value = 0; // No modulation

        const lofiCrush = new Tone.BitCrusher(16); // Start at 16 bits (clean)
        
        // Chain: Filter -> Crusher -> FINAL Reverb
        lofiFilter.connect(lofiCrush);
        lofiCrush.connect(reverb);

        // 2d. Analyser (for visuals)
        // REFACTORED: Changed from 'waveform' to 'fft'
        const analyser = new Tone.Analyser('fft', 256);

        
        // --- 3. Connect our Instruments to the Effects ---
        
        // 3a. Main Synth: Connects to Analyser AND Delay
        synth.connect(analyser);
        synth.connect(pingPongDelay);
        
        // 3b. Analyser: Connects to the Lofi effects chain
        // This is the "dry" signal path for the synth.
        analyser.connect(lofiFilter);

        // 3c. Pad Synth: Connects to Lofi chain (skips delay for a clearer mix)
        padSynth.connect(lofiFilter);
        
        // 3d. Kick: Connects to Lofi chain
        kickSynth.connect(lofiFilter);
        
        // 3e. Hi-Hat: Connects to Lofi chain
        hiHatSynth.connect(lofiFilter);
        
        // 3f. Chime: Connects straight to Reverb (so it's always clean)
        chimeSynth.connect(reverb);


        // --- 4. Define our Musical Content (Scales, Chords) ---

        const scales = {
            ambient: [
                'C4', 'E4', 'G4', 'A4', 'C5',
                'E5', 'G5', 'A5'
            ], // C Major Pentatonic (calm)
            lofi: [
                'C4', 'Eb4', 'F4', 'G4', 'Bb4',
                'C5', 'Eb5', 'F5', 'G5', 'Bb5'
            ], // C Minor Bluesy (moody)
            dance: [
                'C4', 'D4', 'E4', 'G4', 'A4',
                'C5', 'D5', 'E5', 'G5', 'A5'
            ] // C Major Pentatonic (more notes)
        };
        let activeScale = scales.ambient; // Start with ambient

        const chords = {
            ambient: [
                ['C3', 'E3', 'G3', 'B3'], // Cmaj7
                ['F3', 'A3', 'C4', 'E4'], // Fmaj7
                ['G3', 'B3', 'D4', 'F4'], // G7
                ['A3', 'C4', 'E4', 'G4']  // Am7
            ],
            lofi: [
                ['C3', 'Eb3', 'G3', 'Bb3'], // Cm7
                ['F3', 'Ab3', 'C4', 'Eb4'], // Fm7
                ['Ab3', 'C4', 'Eb4', 'G4'], // Abmaj7
                ['G3', 'B3', 'D4', 'F4']  // G7
            ],
            dance: [
                ['C3', 'E3', 'G3'], // C Major
                ['G3', 'B3', 'D4'], // G Major
                ['A3', 'C4', 'E4'], // A Minor
                ['F3', 'A3', 'C4']  // F Major
            ]
        };
        let activeChords = chords.ambient;
        let chordIndex = 0;

        // --- 5. Define our Rhythmic Loops ---

        // 5a. Main Generative Melody Loop
        const generativeLoop = new Tone.Loop((time) => {
            // 1. Decide if we play a note (based on density)
            if (Math.random() < density) {
                // 2. Pick a random note from the active scale
                const note = activeScale[Math.floor(Math.random() * activeScale.length)];
                
                // 3. Play the note
                synth.triggerAttackRelease(note, '8n', time);
            }
        }, '16n'); // This loop runs every 16th note

        // 5b. Ambient Pad Loop
        const padLoop = new Tone.Loop((time) => {
            const chord = activeChords[chordIndex];
            padSynth.triggerAttackRelease(chord, '2m', time);
            chordIndex = (chordIndex + 1) % activeChords.length;
        }, '2m'); // This loop runs every 2 measures

        // 5c. Kick Drum Loop
        const kickLoop = new Tone.Loop((time) => {
            // "4n" = quarter note (four-on-the-floor beat)
            kickSynth.triggerAttackRelease('C1', '8n', time);
        }, '4n');

        // 5d. Hi-Hat Loop
        const hiHatPatterns = {
            ambient: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], // Off
            lofi:    [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], // Off-beat 'shaker' (on the '&')
            dance:   [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]  // Off-beat 8th note
        };
        let hiHatPattern = hiHatPatterns.ambient;
        let hiHatStep = 0;

        const hiHatLoop = new Tone.Loop((time) => {
            let patternStep = hiHatPattern[hiHatStep];
            if (patternStep === 1) {
                hiHatSynth.triggerAttack(time);
            }
            hiHatStep = (hiHatStep + 1) % hiHatPattern.length;
        }, '16n'); // This loop must run every 16th note


        // --- 6. Set Master Transport (BPM) ---
        Tone.Transport.bpm.value = 90; // A calm, slow tempo
        Tone.Transport.swing = 0.2; // Add a little human swing


        // --- 7. Define Visual Loop ---
        // REFACTORED: Replaced with FFT Spectrum Visualizer
        function drawLoop() {
            requestAnimationFrame(drawLoop); // Keep the loop running

            if (!isPlaying) {
                // Clear canvas when not playing
                canvasCtx.clearRect(0, 0, visualCanvas.width, visualCanvas.height);
                return;
            }

            const fftData = analyser.getValue(); // Get frequency data

            // Clear the canvas for the new frame
            canvasCtx.clearRect(0, 0, visualCanvas.width, visualCanvas.height);
            
            const numBars = fftData.length;
            const barWidth = visualCanvas.width / numBars;
            
            // Create a gradient for the bars
            const gradient = canvasCtx.createLinearGradient(0, 0, 0, visualCanvas.height);
            gradient.addColorStop(0, '#6366F1'); // indigo-500
            gradient.addColorStop(0.7, '#8B5CF6'); // purple-500
            gradient.addColorStop(1, '#1F2937'); // gray-800 (fade to bg)

            canvasCtx.fillStyle = gradient;

            for (let i = 0; i < numBars; i++) {
                const db = fftData[i];
                // Normalize the dB value (from -100dB to -20dB)
                const minDb = -100;
                const maxDb = -20;
                let barHeight = ((db - minDb) / (maxDb - minDb)) * visualCanvas.height;
                
                // Clamp values
                if (barHeight < 0) barHeight = 0;
                if (barHeight > visualCanvas.height) barHeight = visualCanvas.height;

                const x = i * barWidth;
                const y = visualCanvas.height - barHeight;

                // Draw the bar (with a 1px gap)
                canvasCtx.fillRect(x, y, barWidth - 1, barHeight);
            }
        }

        
        // --- 8. Define Main Control Functions ---

        // Function to change the mood
        function setMood(newMood) {
            currentMood = newMood; // Set global mood tracker

            // Update button UI
            document.querySelectorAll('.mood-btn').forEach(btn => {
                if (btn.dataset.mood === newMood) {
                    btn.classList.add('mood-active');
                } else {
                    btn.classList.remove('mood-active');
                }
            });

            if (newMood === 'ambient') {
                // Set notes and chords
                activeScale = scales.ambient;
                activeChords = chords.ambient;
                // Set pad synth preset
                padSynth.set(padPresets.ambient);
                // Set Lofi effects "off" (clean signal)
                lofiFilter.frequency.rampTo(20000, 0.5);
                lofiFilter.depth.value = 0;
                lofiCrush.bits.value = 16;
                // Mute kick
                kickSynth.volume.rampTo(-Infinity, 0.5);
                // Mute hi-hat
                hiHatSynth.volume.rampTo(-Infinity, 0.5);
                hiHatPattern = hiHatPatterns.ambient;

            } else if (newMood === 'lofi') {
                // Set notes and chords
                activeScale = scales.lofi;
                activeChords = chords.lofi;
                // Set pad synth preset
                padSynth.set(padPresets.lofi);
                // Set Lofi effects "on"
                lofiFilter.frequency.rampTo(1500, 0.5);
                lofiFilter.depth.value = 0.2; // Add a little wobble
                lofiCrush.bits.value = 8;
                // Mute kick
                kickSynth.volume.rampTo(-Infinity, 0.5);
                // UN-Mute hi-hat (lofi style)
                hiHatSynth.set(hiHatPresets.lofi);
                hiHatPattern = hiHatPatterns.lofi;
                hiHatSynth.volume.rampTo(-12, 0.5); // Quiet 'shaker' volume

            } else if (newMood === 'dance') {
                // Set notes and chords
                activeScale = scales.dance;
                activeChords = chords.dance;
                // Set pad synth preset
                padSynth.set(padPresets.dance);
                // Set Lofi effects "off"
                lofiFilter.frequency.rampTo(20000, 0.5);
                lofiFilter.depth.value = 0;
                lofiCrush.bits.value = 16;
                // UN-Mute kick
                kickSynth.volume.rampTo(0, 0.1);
                // UN-Mute hi-hat (dance style)
                hiHatSynth.set(hiHatPresets.dance);
                hiHatPattern = hiHatPatterns.dance;
                hiHatSynth.volume.rampTo(-8, 0.1);
                // Suggest a faster tempo
                if (Tone.Transport.bpm.value < 100) {
                    tempoSlider.value = 110;
                    Tone.Transport.bpm.value = 110;
                    tempoValue.textContent = "110 bpm";
                }
            }
            
            // Reset chord index to avoid weird transitions
            chordIndex = 0;
            hiHatStep = 0; // Reset hi-hat pattern
        }

        // --- NEW: Preset Management Functions ---

        // Load all presets from localStorage
        function loadPresets() {
            const presets = localStorage.getItem(PRESETS_STORAGE_KEY);
            return presets ? JSON.parse(presets) : [];
        }

        // Save an array of presets to localStorage
        function savePresets(presets) {
            localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(presets));
        }

        // Update the <select> dropdown menu with current presets
        function updatePresetMenu() {
            const presets = loadPresets();
            presetMenu.innerHTML = ''; // Clear existing options
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Select a preset...";
            presetMenu.appendChild(defaultOption);
            
            // Add saved presets
            presets.forEach((preset, index) => {
                const option = document.createElement('option');
                option.value = index; // Use index as the value
                option.textContent = preset.name;
                presetMenu.appendChild(option);
            });
        }
        
        // Show a temporary message in the preset help text area
        function showPresetMessage(message, isError = false) {
            presetHelpText.textContent = message;
            presetHelpText.className = isError ? 'text-xs text-red-400 h-4' : 'text-xs text-green-400 h-4';
            
            setTimeout(() => {
                presetHelpText.textContent = '';
                presetHelpText.className = 'text-xs text-gray-500 h-4';
            }, 3000);
        }
        
        // Reset the preset UI to its default state
        function resetPresetUI() {
            loadPresetUI.classList.remove('hidden');
            savePresetUI.classList.add('hidden');
            deleteConfirmUI.classList.add('hidden');
            presetNameInput.value = ''; // Clear input
        }

        // --- End Preset Functions ---

        // NEW: Function to get the current state of all controls
        function getCurrentState() {
            return {
                mood: currentMood,
                tempo: tempoSlider.value,
                density: densitySlider.value,
                reverb: reverbSlider.value,
                delay: delaySlider.value
            };
        }

        // NEW: Function to apply a state object to the UI and audio engine
        function applyState(state) {
            // Set sliders
            tempoSlider.value = state.tempo;
            densitySlider.value = state.density;
            reverbSlider.value = state.reverb;
            delaySlider.value = state.delay;

            // Trigger 'input' event to update audio and text labels
            // This is crucial so we don't have to write the update logic twice
            tempoSlider.dispatchEvent(new Event('input'));
            densitySlider.dispatchEvent(new Event('input'));
            reverbSlider.dispatchEvent(new Event('input'));
            delaySlider.dispatchEvent(new Event('input'));

            // Set mood
            setMood(state.mood);
        }

        // NEW: Function to robustly copy text to clipboard (works in iFrames)
        function copyToClipboard(text) {
            const shareTextArea = document.getElementById('shareTextArea');
            shareTextArea.value = text;
            shareTextArea.select();
            try {
                document.execCommand('copy');
                return true;
            } catch (err) {
                console.error('Failed to copy text: ', err);
                return false;
            }
        }

// NEW: Function to read parameters from URL on load
        function loadStateFromURL() {
            const params = new URLSearchParams(window.location.search);
            // Check if *any* param exists. If not, use defaults.
            if (!params.has('mood')) {
                return; // No params, just load defaults
            }
            
            const state = {
                mood: params.get('mood') || 'ambient',
                tempo: parseInt(params.get('tempo')) || 90,
                density: parseInt(params.get('density')) || 35,
                reverb: parseInt(params.get('reverb')) || 25,
                delay: parseInt(params.get('delay')) || 10
            };
            
            applyState(state);
        }

        // Function to start the music
        async function startMusic(focusMode = false) {
            if (isPlaying) return;
            await Tone.start();
            
            Tone.Transport.start();
            isPlaying = true;
            isFocusMode = focusMode; // Set whether we are in focus mode

            // Transition UI to "Active" state
            idleControls.classList.add('fade-out');
            idleControls.classList.remove('fade-in');
            activeControls.classList.add('fade-in');
            activeControls.classList.remove('fade-out');
            
            // Set timer display text
            if (isFocusMode) {
                // Timer will be updated by its own loop
            } else {
                timerDisplay.textContent = "Free Play";
            }
            
            // REFACTORED: Enable record button
            recordButton.disabled = false;
            recordHelpText.style.display = 'none';
        }
        
        // Function to stop the music
        function stopMusic() {
            if (!isPlaying) return;
            
            Tone.Transport.stop();
            isPlaying = false;
            
            // Stop the focus timer if it's running
            if (focusTimerInterval) {
                stopFocusTimer(false); // Stop without chime
            }
            
            // REFACTORED: Stop recording if it was active
            if (isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordButton.textContent = 'Start Recording';
                recordButton.classList.remove('is-recording');
            }

            // REFACTORED: Disable record button
            recordButton.disabled = true;
            recordHelpText.style.display = 'block';

            resetUIToIdle();
        }
        
        // Function to reset UI to its idle state
        function resetUIToIdle() {
            idleControls.classList.add('fade-in');
            idleControls.classList.remove('fade-out');
            activeControls.classList.add('fade-out');
            activeControls.classList.remove('fade-in');

            // Reset start button text (in case it was loading)
            startButton.disabled = false;
            startButton.textContent = 'Start';
        }

        
        // --- 9. Define Focus Timer Functions ---

        function startFocusTimer(minutes) {
            // Start music, telling it we're in focus mode
            startMusic(true);
            
            const durationInSeconds = minutes * 60;
            focusTimerEndTime = Date.now() + durationInSeconds * 1000;
            
            // Start the timer
            updateTimerDisplay(); // Call immediately
            focusTimerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function stopFocusTimer(playChime = false) {
            if (!focusTimerInterval) {
                // This handles case where "Stop" is hit in "Free Play"
                if (isPlaying) stopMusic();
                return;
            }
            
            clearInterval(focusTimerInterval);
            focusTimerInterval = null;
            isFocusMode = false;
            
            if (playChime) {
                // Play a nice chime sound
                chimeSynth.triggerAttackRelease('C5', '2n', Tone.now());
                chimeSynth.triggerAttackRelease('E5', '2n', Tone.now() + 0.5);
                chimeSynth.triggerAttackRelease('G5', '2n', Tone.now() + 1.0);
                
                // Gently fade out music over 5 seconds
                Tone.Transport.scheduleOnce((time) => {
                    stopMusic();
                }, "+5");
            } else {
                // If stopped manually, just stop the music
                stopMusic();
            }
        }
        
        function updateTimerDisplay() {
            if (!isFocusMode) return;
            
            const now = Date.now();
            const remaining = Math.max(0, focusTimerEndTime - now);
            const seconds = Math.floor((remaining / 1000) % 60);
            const minutes = Math.floor((remaining / (1000 * 60)) % 60);
            
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            if (remaining === 0) {
                stopFocusTimer(true); // Timer finished, play chime
            }
        }


        // --- 10. Add Event Listeners ---
        
        // Wait for Tone.js to be loaded
        Tone.loaded().then(() => {
            // All synths and loops are ready.
            // Enable the start button.
            startButton.disabled = false;
            startButton.textContent = 'Start';
            
            // Start all loops (they won't make sound until Tone.Transport.start() is called)
            generativeLoop.start(0);
            padLoop.start(0);
            kickLoop.start(0);
            hiHatLoop.start(0);
            
            // --- NEW: Load state from URL ---
            // This must run BEFORE resetUIToIdle to set the controls
            loadStateFromURL();

            // Set initial UI state
            resetUIToIdle();

            // --- NEW: Populate preset menu on load ---
            updatePresetMenu();

            // --- NEW: Setup Canvas Sizing and Start Draw Loop ---
            function resizeCanvas() {
                // Set canvas internal resolution to match its displayed size
                visualCanvas.width = visualContainer.clientWidth;
                visualCanvas.height = visualContainer.clientHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to set initial size
            drawLoop(); // Start the draw loop
            
            // --- Setup Media Recorder ---
            mediaRecorder = new MediaRecorder(recordDestination.stream, { mimeType: 'audio/webm' });

            mediaRecorder.ondataavailable = (evt) => {
                if (evt.data.size > 0) {
                    recordedChunks.push(evt.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `MelodicFlow-Recording.webm`;
                a.click();
                URL.revokeObjectURL(url);
                recordedChunks = [];
            };
            
        });

        // Main Start Button
        startButton.addEventListener('click', () => {
            startMusic(false); // Start in "Free Play" mode
        });
        
        // Stop Button (handles all stopping)
        stopFocusBtn.addEventListener('click', () => { 
            stopFocusTimer(false); // Stop manually, no chime
        });

        // --- Slider Listeners ---
        tempoSlider.addEventListener('input', (e) => {
            const bpm = parseInt(e.target.value);
            Tone.Transport.bpm.value = bpm;
            tempoValue.textContent = `${bpm} bpm`;
        });

        densitySlider.addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            density = percent / 100.0;
            densityValue.textContent = `${percent}%`;
        });

        reverbSlider.addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            reverb.wet.value = percent / 100.0;
            reverbValue.textContent = `${percent}%`;
        });

        delaySlider.addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            pingPongDelay.wet.value = percent / 100.0;
            delayValue.textContent = `${percent}%`;
        });
        
        // --- Mood Switcher Listener ---
        moodSwitcher.addEventListener('click', (e) => {
            if (e.target.classList.contains('mood-btn')) {
                const newMood = e.target.dataset.mood;
                setMood(newMood);
            }
        });
        
        // --- Focus Timer Listeners ---
        focusTimeSelector.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const minutes = parseInt(e.target.dataset.time);
                startFocusTimer(minutes);
            }
        });

        // --- Record Button Listener ---
        recordButton.addEventListener('click', () => {
            if (!isRecording) {
                // Start recording
                if (mediaRecorder && mediaRecorder.state === 'inactive') {
                    mediaRecorder.start();
                    isRecording = true;
                    recordButton.textContent = 'Stop Recording';
                    recordButton.classList.add('is-recording');
                }
            } else {
                // Stop recording
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordButton.textContent = 'Start Recording';
                    recordButton.classList.remove('is-recording');
                }
            }
        });

        // --- NEW: Share Button Listener ---
        const shareButton = document.getElementById('shareButton');
        shareButton.addEventListener('click', () => {
            const state = getCurrentState();
            const params = new URLSearchParams(state).toString();
            const shareURL = `${window.location.origin}${window.location.pathname}?${params}`;
            
            if (copyToClipboard(shareURL)) {
                // Give user feedback
                const originalText = shareButton.textContent;
                shareButton.textContent = 'Link Copied!';
                shareButton.classList.add('bg-indigo-600', 'text-white'); // Make it "pop"
                
                setTimeout(() => {
                    shareButton.textContent = originalText;
                    shareButton.classList.remove('bg-indigo-600', 'text-white');
                }, 2000);
            } else {
                // REFACTORED: No alert
                showPresetMessage('Could not copy link to clipboard.', true);
            }
        });

        // --- REFACTORED: Preset Button Listeners (No prompts/alerts) ---
        
        // "Save Current" Button
        savePresetButton.addEventListener('click', () => {
            // Show the save UI
            loadPresetUI.classList.add('hidden');
            savePresetUI.classList.remove('hidden');
            presetNameInput.focus();
        });

        // "Cancel Save" Button
        cancelSaveButton.addEventListener('click', () => {
            resetPresetUI();
        });

        // "Confirm Save" Button
        confirmSaveButton.addEventListener('click', () => {
            const name = presetNameInput.value;
            if (!name || name.trim() === '') {
                showPresetMessage('Please enter a name.', true);
                return;
            }
            
            const presets = loadPresets();
            const newState = getCurrentState();
            
            presets.push({ name: name.trim(), state: newState });
            savePresets(presets);
            updatePresetMenu(); // Refresh the menu
            
            // Automatically select the new preset
            presetMenu.value = presets.length - 1;
            
            resetPresetUI();
            showPresetMessage('Preset saved!', false);
        });

        // Load Preset from Menu
        presetMenu.addEventListener('change', (e) => {
            const presetIndex = e.target.value;
            if (presetIndex === "") return; // "Select a preset" was chosen
            
            const presets = loadPresets();
            const selectedPreset = presets[presetIndex];
            
            if (selectedPreset) {
                applyState(selectedPreset.state);
            }
        });
        
        // "Delete" Button
        deletePresetButton.addEventListener('click', () => {
            const presetIndex = presetMenu.value;
            if (presetIndex === "") {
                showPresetMessage('Select a preset to delete.', true);
                return;
            }
            
            // Show the confirm UI
            loadPresetUI.classList.add('hidden');
            deleteConfirmUI.classList.remove('hidden');
        });

        // "Cancel Delete" Button
        cancelDeleteButton.addEventListener('click', () => {
            resetPresetUI();
        });

        // "Confirm Delete" Button
        confirmDeleteButton.addEventListener('click', () => {
            const presetIndex = presetMenu.value;
            // No need to check again, but good practice
            if (presetIndex === "") {
                resetPresetUI();
                return;
            } 
            
            const presets = loadPresets();
            presets.splice(presetIndex, 1); // Remove the preset at that index
            savePresets(presets);
            updatePresetMenu(); // Refresh the menu
            
            resetPresetUI();
            showPresetMessage('Preset deleted.', false);
        });

    </script></body>
</html>